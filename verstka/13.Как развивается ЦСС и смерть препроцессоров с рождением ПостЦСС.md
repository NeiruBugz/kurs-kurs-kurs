# Как развивается ЦСС и смерть препроцессоров с рождением ПостЦСС
ЦСС не стоит на месте — а как нам писать будущий ЦСС уже сегодня?

ЦСС развивается — когда-то мы получили стандарт ЦСС3, а теперь W3C (помните? консорциум, который развивает веб) решил перейти на релизы [конкретных спецификаций](https://www.w3.org/Style/CSS/current-work) разными рабочими группами, поэтому теперь у нас есть не ЦСС4, не ЦСС5, не ЦСС 3.2.1.1.3.211.522, а конкретные фичи и их реализации в браузере.

Например, во [многих браузерах](https://caniuse.com/#search=css%20variables) уже есть [**Custom Properties**](https://www.w3.org/TR/css-variables/) — это переменные в ЦССе.

```css
:root {
  --mainColor: red;
}

a {
  color: var(--mainColor);
}
```

Или [**Custom Media Queries**](https://drafts.csswg.org/mediaqueries-5/#custom-mq):

```css
@custom-media --md-viewport (min-width: 796px);

@media (--md-viewport) {
  /* styles for small viewport */
}
```

А также [`image-set()`](https://drafts.csswg.org/css-images-3/#image-set-notation) для нескольких изображений:

```css
.foo {
  background-image: image-set(
    url(img/bg.png) 1x,
    url(img/bg-2x.png) 2x,
    url(bg-print.png) 600dpi
  );
}
```

Псевдокласс [`:matches()`](http://dev.w3.org/csswg/selectors-4/#matches):

```css
.description:matches(:first-child, .special) {
  color: red;
}
```

И много других. Но как это всё использовать в проекте? Для этого существует [cssnext](http://cssnext.io/) — пакет плагинов для ПостЦСС.

## [ПостЦСС](http://postcss.org/)

… ПостЦСС? Чего?

ПостЦСС это утилита, которая трансформирует ваш ЦСС с помощью джс-плагинов.

Чисто технически, ПостЦСС это парсер ЦСС — он разбирает ваш ЦСС на понятный себе формат, с которым уже потом работают плагины. Например, есть плагин [Autoprefixer](https://github.com/postcss/autoprefixer): он на выходе выдаёт код с браузерными префиксами:

```css
/* input */
a {
  display: flex;
}

/* output */
a {
  display: -webkit-box;
  display: -webkit-flex;
  display: -ms-flexbox;
  display: flex;
}
```

Или тот же cssnext:

```css
/* input */
:root {
  --red: #d33;
}
a {
  &:hover {
    color: color(var(--red) a(54%));
  }
}

/* output */
a:hover {
  color: #dd3333;
  color: rgba(221, 51, 51, 0.54);
}
```

Удобно? Чертовски.

Кстати, у фронтэндеров есть [ESLint](https://eslint.org) — штука, которая следит за качеством кода, а у верстальщиков — [stylelint](https://stylelint.io/). Конечно, есть [плагин](https://github.com/shinnn/vscode-stylelint) для ВСКода — поставите и будете в редакторе видеть, в чём у вас говнокод.

### Настроим ПостЦСС с `cssnext`

Помните, в первом уроке я говорил, что большинство приложений и утилит для разработчиков идут только с командным интерфейсом и работать с ними можно только в консоли? Вот теперь пора вернуться к Терминалу.

#### Нода и пакетные менеджеры `npm` и `yarn`

Для начала нам нужно поставить Ноду (Node.js) — она выполняет джс-файлы не в браузере.

##### Windows

Скачайте с сайта [nodejs.org](https://nodejs.org/en/).

##### Unix

Поставьте из своих репозиториев: `apt-get`, `yum` и так далее.

##### macOS

В Маке нет встроенного пакетного менеджера (а зря!), поэтому сначала нужно поставить [Homebrew](http://brew.sh/).

Поставьте Ноду через команду `brew install node`.

---

Вместе с Нодой идёт пакетный менеджер [`npm`](https://www.npmjs.com/) — node package manager.

Пакетный менеджер делится на две вещи: база пакетов и клиент, который работает с ней. Команда `npm` и есть этот самый клиент.

Проблема в том, что нпм работал плохо и медленно, поэтому ребята из Фейсбука сделали свой пакетный менеджер [Ярн](http://yarnpkg.com/): он работает быстрее и предсказуемее.

Что такое вообще пакетный менеджер и почему предсказуемость и скорость так важны?

* **Во-первых**, во время разработки вы будете использовать много сторонних модулей — ведь кучу вещей кто-то за вас уже когда-то написал, осталось это только подключить и использовать.

* **Во-вторых**, говоря про скорость: у каждого пакета могут быть свои зависимости (по 2-3), а в проекте, например, 100 зависимостей. Вместо 100 у вас устанавливается 300: 100 основных пакетов и их зависимостей. Может быть долго!

* **В-третьих**, пакеты соблюдают [Семвер](http://semver.org/) — семантичное версионирование. Дело в том, что пакеты обновляются, а ломать работающие приложения из-за этого не хочется, поэтому у нас есть версионирование `MAJOR.MINOR.PATCH` (например, Реакт сейчас — 16.0.0). `npm` раньше не уважал прописанные в `package.json` версии и порою всё ломалось. В Ярне такого нет изначально.

Пакеты проекта в джс-мире описываются в файле [`package.json`](https://docs.npmjs.com/files/package.json) в секциях `dependencies` и `devDependencies`.

#### dependencies

Все зависимости, которые **используются в приложении**: Реакт, [normalize.css](https://necolas.github.io/normalize.css/), готовая адаптивная сетка [flexboxgrid2](https://github.com/evgenyrodionov/flexboxgrid2).

#### devDependencies

Зависимости, которые **помогают работать приложению**: Стайллинт или тот же ПостЦСС.

Как поставить Ярн? [Описано в документации](https://yarnpkg.com/en/docs/install).

Как использовать пакетный менеджер? Как и `brew` из Макоси! `yarn add [название пакета]`, например, `yarn add react` установит Реакт последней версии и сохранит его в `package.json`.

Команда `yarn` (сокращенно от `yarn install`) установит все зависимости, которые указаны в `package.json`.

---

Окей, Ноду поставили, с пакетным менеджером разобрались, теперь нужно поставить ПостЦСС и настроить его на работу с цсснекст.

Сначала нужно выполнить команду `yarn init`: она создаст файл `package.json`, в котором будут указаны настройки проекта.

После — читаем [установку цсснекст](http://cssnext.io/setup/): нам нужно поставить две зависимости postcss и postcss-cssnext через команду

```sh
npm install postcss postcss-cssnext
```

Нпм нас, конечно, мало интересует, поэтому мы будем сразу ставить через Ярн и в `devDeps`:

```sh
yarn add --dev postcss postcss-cssnext
```

Ярн установит и сохранит в `package.json`:

```json
{
  ...
  "devDependencies": {
    "postcss": "6.0.15",
    "postcss-cssnext": "3.0.2"
  }
  ...
}
```

Окей! В документации сказано, что можно использовать разными способами, но нас интересует CLI (command line interface): мы будем запускать в Терминале.

![](https://i.imgur.com/dcuoIG2.png)

Для этого нам нужно поставить [postcss-cli](https://www.npmjs.com/package/postcss-cli) (да, ссылка на нпм, хоть и будем ставить через Ярн — потому что Ярн использует базу нпма).

```sh
yarn add --dev postcss-cli
```

Затем создаём файл `postcss.config.js` (ваш первый опыт с джсом!) и пишем там:

```
module.exports = {
  plugins: [
    require('postcss-cssnext')()
  ]
}
```

Про `module.exports` и `require()` мы поговорим позже.

Окей, теперь нужно проверить, что всё работает. У нас будут файлы `styles/style.css` и `build/styles/style.css` — во втором будет наш ЦСС, _скомпилированный_ через ПостЦСС и цсснекст.

```
postcss [input.css] [OPTIONS] [-o|--output output.css] [-w|--watch]
```

Наша команда будет выглядеть так:

```
yarn postcss styles/style.css --output build/styles/style.css --watch
```

Что за `--watch`? `postcss-cli` будет перезапускаться на каждое изменение файлов. Без `--watch` будет один раз компилироваться.

## Итог

Мы узнали про будущий ЦСС и как его заставить работать уже сегодня: через ПостЦСС и цсснекст.

## Задание

Прочитайте [фичи цсснекст](http://cssnext.io/features/) и переводите свои стили на будущий ЦСС.
